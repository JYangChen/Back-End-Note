## Spring

### Spring的优点有哪些呢？

- Spring的**依赖注入**将对象之间的依赖关系交给了框架来处理，减小了各个组件之间的耦合性；
- **AOP面向切面编程**，可以将通用的任务抽取出来，复用性更高；
- Spring对于其余**主流框架都提供了很好的支持**，代码的侵入性很低。



### IOC

IOC也叫**控制反转，将对象间的依赖关系交给Spring容器**，使用配置文件来创建所依赖的对象，由**主动**创建对象改为了**被动**方式，实现解耦合。

**IOC容器的初始化过程就是对Bean定义资源的定位、载入和注册**

#### BeanFactory和FactoryBean的区别：

- **BeanFactory**：Bean工厂，是一个工厂(Factory)， 是Spring IOC容器的最顶层接口，它的作用是**管理Bean，即实例化、定位、配置**应用程序中的对象及建立这些对象间的依赖。
- **FactoryBean**：工厂Bean，**是一个Bean，作用是产生其他Bean实例**，需要提供一个工厂方法，该方法用来返回其他Bean实例。



### AOP

**AOP，**面向切面编程是指当需要在某一个方法之前或者之后做一些额外的操作，比如说日志记录，权限判断，异常统计等，可以利用AOP**将功能代码从业务逻辑代码中分离出来。**

- Aspect：切面，由一系列切点、增强和引入组成的模块对象，可定义优先级，从而影响增强和引入的执行顺序。事务管理（Transaction management）在java企业应用中就是一个很好的切面样例。
- Join point：接入点，程序执行期的一个点，例如方法执行、类初始化、异常处理。 在Spring AOP中，接入点始终表示方法执行。
- Advice：增强，切面在特定接入点的执行动作，包括 “around,” “before” and "after"等多种类型。包含Spring在内的许多AOP框架，通常会使用拦截器来实现增强，围绕着接入点维护着一个拦截器链。
- Pointcut：切点，用来匹配特定接入点的谓词（表达式），增强将会与切点表达式产生关联，并运行在任何切点匹配到的接入点上。通过切点表达式匹配接入点是AOP的核心，Spring默认使用AspectJ的切点表达式。
- Introduction：引入，为某个type声明额外的方法和字段。Spring AOP允许你引入任何接口以及它的默认实现到被增强对象上。
- Target object：目标对象，被一个或多个切面增强的对象。也叫作被增强对象。既然Spring AOP使用运行时代理（runtime proxies），那么目标对象就总是代理对象。
- AOP proxy：AOP代理，为了实现切面功能一个对象会被AOP框架创建出来。在Spring框架中AOP代理的默认方式是：有接口，就使用基于接口的JDK动态代理，否则使用基于类的CGLIB动态代理。但是我们可以通过设置proxy-target-class="true"，完全使用CGLIB动态代理。
- Weaving：织入，将一个或多个切面与类或对象链接在一起创建一个被增强对象。织入能发生在编译时 （compile time ）(使用AspectJ编译器)，加载时（load time），或运行时（runtime） 。Spring AOP默认就是运行时织入，可以通过枚举AdviceMode来设置。

#### Spring中的AOP主要有两种实现方式：

- **使用JDK动态代（dai）理实现**，使用java.lang.reflection.Proxy类来处理
- **使用cglib来实现**

#### Spring AOP对这两种代（dai）理方式的选择：

- 如果目标对象实现了接口，默认情况下会采用JDK的动态代（dai）理实现AOP，也可以强制使用cglib实现AOP；
- 如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代（dai）理和cglib之间转换。

### Spring的事务

- **编程式事务管理**：使用TransactionTemplate实现。
- **声明式事务管理**：建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。

#### 声明式事务的优点：

就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。

#### 事务选择：

声明式事务管理要优于编程式事务管理，这正是Spring倡导的**非侵入式的开发**方式，使业务代码不受污染，只要**加上注解**就可以获得完全的事务支持。唯一不足之处是声明式事务的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。

**当多个Spring事务存在的时候，Spring定义了下边的7个传播行为来处理这些事务行为：**

- **PROPAGATION_REQUIRED**：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，**该设置是最常用的设置。**
- PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
- PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
- PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。
- PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。

### Spring中Bean的作用域

- **singleton** : Bean在每个Spring IOC 容器中只有一个实例，默认作用域。
- **prototype**：一个Bean的定义可以有多个实例。
- **request**：每次http请求都会创建一个Bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。
- **session**：在一个HTTP Session中，一个Bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
- **global-session**：在一个全局的HTTP Session中，一个Bean对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。

## MyBatis

### MyBatis中 # 和 $ 的区别是什么？

**能用#号就尽量不要使用$符号**，它们的区别主要体现在下边几点：

- \#符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号
- $符号将传入的数据**直接显示**在生成的SQL语句中。
- \#符号**存在预编译的过程**，对问号赋值，防止**SQL注入**。
- $符号是**直译**的方式，一般用在**order by ${列名}**语句中。

### MyBatis的缓存机制

- **一级缓存（同一个SqlSession）:**

基于 HashMap的本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有缓存就将清空，默认打开一级缓存。

- **二级缓存（同一个SqlSessionFactory）：**

二级缓存与一级缓存其机制相同，默认也是采用 HashMap的本地存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源。